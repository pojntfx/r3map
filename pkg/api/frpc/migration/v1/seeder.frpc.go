// Code generated by fRPC Go v0.8.0, DO NOT EDIT.
// source: seeder.proto

package v1

import (
	"errors"
	"github.com/loopholelabs/polyglot/v2"
	"net"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"
)

var (
	ErrDecodeNil = errors.New("cannot decode into a nil root struct")
)

type ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs struct {
	error error
	flags uint8

	Length int32
	Off    int64
}

func NewComPojtingerFelicitasR3MapMigrationV1ReadAtArgs() *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs {
	return &ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Int32(x.Length).Int64(x.Off)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Length, err = d.Int32()
	if err != nil {
		return err
	}
	x.Off, err = d.Int64()
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1ReadAtReply struct {
	error error
	flags uint8

	N int32
	P []byte
}

func NewComPojtingerFelicitasR3MapMigrationV1ReadAtReply() *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply {
	return &ComPojtingerFelicitasR3MapMigrationV1ReadAtReply{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Int32(x.N).Bytes(x.P)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.N, err = d.Int32()
	if err != nil {
		return err
	}
	x.P, err = d.Bytes(x.P)
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1TrackArgs struct {
	error error
	flags uint8
}

func NewComPojtingerFelicitasR3MapMigrationV1TrackArgs() *ComPojtingerFelicitasR3MapMigrationV1TrackArgs {
	return &ComPojtingerFelicitasR3MapMigrationV1TrackArgs{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1TrackReply struct {
	error error
	flags uint8
}

func NewComPojtingerFelicitasR3MapMigrationV1TrackReply() *ComPojtingerFelicitasR3MapMigrationV1TrackReply {
	return &ComPojtingerFelicitasR3MapMigrationV1TrackReply{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackReply) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackReply) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackReply) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1TrackReply) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1SyncArgs struct {
	error error
	flags uint8
}

func NewComPojtingerFelicitasR3MapMigrationV1SyncArgs() *ComPojtingerFelicitasR3MapMigrationV1SyncArgs {
	return &ComPojtingerFelicitasR3MapMigrationV1SyncArgs{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1SyncReply struct {
	error error
	flags uint8

	DirtyOffsets []int64
}

func NewComPojtingerFelicitasR3MapMigrationV1SyncReply() *ComPojtingerFelicitasR3MapMigrationV1SyncReply {
	return &ComPojtingerFelicitasR3MapMigrationV1SyncReply{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncReply) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncReply) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.DirtyOffsets)), polyglot.Int64Kind)
		for _, v := range x.DirtyOffsets {
			polyglot.Encoder(b).Int64(v)
		}
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncReply) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1SyncReply) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.Int64Kind)
	if err != nil {
		return err
	}
	if uint32(len(x.DirtyOffsets)) != sliceSize {
		x.DirtyOffsets = make([]int64, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.DirtyOffsets[i], err = d.Int64()
		if err != nil {
			return err
		}
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1CloseArgs struct {
	error error
	flags uint8
}

func NewComPojtingerFelicitasR3MapMigrationV1CloseArgs() *ComPojtingerFelicitasR3MapMigrationV1CloseArgs {
	return &ComPojtingerFelicitasR3MapMigrationV1CloseArgs{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type ComPojtingerFelicitasR3MapMigrationV1CloseReply struct {
	error error
	flags uint8
}

func NewComPojtingerFelicitasR3MapMigrationV1CloseReply() *ComPojtingerFelicitasR3MapMigrationV1CloseReply {
	return &ComPojtingerFelicitasR3MapMigrationV1CloseReply{}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseReply) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseReply) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseReply) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ComPojtingerFelicitasR3MapMigrationV1CloseReply) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type Seeder interface {
	ReadAt(context.Context, *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) (*ComPojtingerFelicitasR3MapMigrationV1ReadAtReply, error)
	Track(context.Context, *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) (*ComPojtingerFelicitasR3MapMigrationV1TrackReply, error)
	Sync(context.Context, *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) (*ComPojtingerFelicitasR3MapMigrationV1SyncReply, error)
	Close(context.Context, *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) (*ComPojtingerFelicitasR3MapMigrationV1CloseReply, error)
}

const connectionContextKey int = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(seeder Seeder, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewComPojtingerFelicitasR3MapMigrationV1ReadAtArgs()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = seeder.ReadAt(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewComPojtingerFelicitasR3MapMigrationV1TrackArgs()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ComPojtingerFelicitasR3MapMigrationV1TrackReply
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = seeder.Track(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewComPojtingerFelicitasR3MapMigrationV1SyncArgs()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ComPojtingerFelicitasR3MapMigrationV1SyncReply
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = seeder.Sync(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewComPojtingerFelicitasR3MapMigrationV1CloseArgs()
		err := req.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ComPojtingerFelicitasR3MapMigrationV1CloseReply
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = seeder.Close(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(outgoing.Content.Len())
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type subSeederClient struct {
	client            *frisbee.Client
	nextReadAt        uint16
	nextReadAtMu      sync.RWMutex
	inflightReadAt    map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply
	inflightReadAtMu  sync.RWMutex
	nextTrack         uint16
	nextTrackMu       sync.RWMutex
	inflightTrack     map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1TrackReply
	inflightTrackMu   sync.RWMutex
	nextSync          uint16
	nextSyncMu        sync.RWMutex
	inflightSync      map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1SyncReply
	inflightSyncMu    sync.RWMutex
	nextClose         uint16
	nextCloseMu       sync.RWMutex
	inflightClose     map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1CloseReply
	inflightCloseMu   sync.RWMutex
	nextStreamingID   uint16
	nextStreamingIDMu sync.RWMutex
}
type Client struct {
	*frisbee.Client
	Seeder *subSeederClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.Seeder.inflightReadAtMu.RLock()
		if ch, ok := c.Seeder.inflightReadAt[incoming.Metadata.Id]; ok {
			c.Seeder.inflightReadAtMu.RUnlock()
			res := NewComPojtingerFelicitasR3MapMigrationV1ReadAtReply()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.Seeder.inflightReadAtMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.Seeder.inflightTrackMu.RLock()
		if ch, ok := c.Seeder.inflightTrack[incoming.Metadata.Id]; ok {
			c.Seeder.inflightTrackMu.RUnlock()
			res := NewComPojtingerFelicitasR3MapMigrationV1TrackReply()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.Seeder.inflightTrackMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.Seeder.inflightSyncMu.RLock()
		if ch, ok := c.Seeder.inflightSync[incoming.Metadata.Id]; ok {
			c.Seeder.inflightSyncMu.RUnlock()
			res := NewComPojtingerFelicitasR3MapMigrationV1SyncReply()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.Seeder.inflightSyncMu.RUnlock()
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.Seeder.inflightCloseMu.RLock()
		if ch, ok := c.Seeder.inflightClose[incoming.Metadata.Id]; ok {
			c.Seeder.inflightCloseMu.RUnlock()
			res := NewComPojtingerFelicitasR3MapMigrationV1CloseReply()
			res.Decode((*incoming.Content).Bytes()[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.Seeder.inflightCloseMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.Seeder = new(subSeederClient)
	c.Seeder.client = c.Client
	c.Seeder.nextReadAtMu.Lock()
	c.Seeder.nextReadAt = 0
	c.Seeder.nextReadAtMu.Unlock()
	c.Seeder.inflightReadAt = make(map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply)
	c.Seeder.nextTrackMu.Lock()
	c.Seeder.nextTrack = 0
	c.Seeder.nextTrackMu.Unlock()
	c.Seeder.inflightTrack = make(map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1TrackReply)
	c.Seeder.nextSyncMu.Lock()
	c.Seeder.nextSync = 0
	c.Seeder.nextSyncMu.Unlock()
	c.Seeder.inflightSync = make(map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1SyncReply)
	c.Seeder.nextCloseMu.Lock()
	c.Seeder.nextClose = 0
	c.Seeder.nextCloseMu.Unlock()
	c.Seeder.inflightClose = make(map[uint16]chan *ComPojtingerFelicitasR3MapMigrationV1CloseReply)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subSeederClient) ReadAt(ctx context.Context, req *ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs) (res *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply, err error) {
	ch := make(chan *ComPojtingerFelicitasR3MapMigrationV1ReadAtReply, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextReadAtMu.Lock()
	c.nextReadAt += 1
	id := c.nextReadAt
	c.nextReadAtMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightReadAtMu.Lock()
	c.inflightReadAt[id] = ch
	c.inflightReadAtMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightReadAtMu.Lock()
	delete(c.inflightReadAt, id)
	c.inflightReadAtMu.Unlock()
	packet.Put(p)
	return
}

func (c *subSeederClient) Track(ctx context.Context, req *ComPojtingerFelicitasR3MapMigrationV1TrackArgs) (res *ComPojtingerFelicitasR3MapMigrationV1TrackReply, err error) {
	ch := make(chan *ComPojtingerFelicitasR3MapMigrationV1TrackReply, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextTrackMu.Lock()
	c.nextTrack += 1
	id := c.nextTrack
	c.nextTrackMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightTrackMu.Lock()
	c.inflightTrack[id] = ch
	c.inflightTrackMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightTrackMu.Lock()
	delete(c.inflightTrack, id)
	c.inflightTrackMu.Unlock()
	packet.Put(p)
	return
}

func (c *subSeederClient) Sync(ctx context.Context, req *ComPojtingerFelicitasR3MapMigrationV1SyncArgs) (res *ComPojtingerFelicitasR3MapMigrationV1SyncReply, err error) {
	ch := make(chan *ComPojtingerFelicitasR3MapMigrationV1SyncReply, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextSyncMu.Lock()
	c.nextSync += 1
	id := c.nextSync
	c.nextSyncMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightSyncMu.Lock()
	c.inflightSync[id] = ch
	c.inflightSyncMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightSyncMu.Lock()
	delete(c.inflightSync, id)
	c.inflightSyncMu.Unlock()
	packet.Put(p)
	return
}

func (c *subSeederClient) Close(ctx context.Context, req *ComPojtingerFelicitasR3MapMigrationV1CloseArgs) (res *ComPojtingerFelicitasR3MapMigrationV1CloseReply, err error) {
	ch := make(chan *ComPojtingerFelicitasR3MapMigrationV1CloseReply, 1)
	p := packet.Get()
	p.Metadata.Operation = 13

	c.nextCloseMu.Lock()
	c.nextClose += 1
	id := c.nextClose
	c.nextCloseMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())
	c.inflightCloseMu.Lock()
	c.inflightClose[id] = ch
	c.inflightCloseMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightCloseMu.Lock()
	delete(c.inflightClose, id)
	c.inflightCloseMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
